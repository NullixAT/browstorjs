class BrowstorJS{constructor(){this.workerMsgCount=0,this.workerMsgCallbacks={}}static handleServiceWorkerEvents(e,r=!0){const n="_browstorJS/";switch(e.type){case"activate":r&&self.clients.claim();break;case"message":r&&self.clients.claim();const t=e.data;if(!t||!t.browstorJsGetFileUrl)return!1;const o=t.browstorJsGetFileUrl;e.source.postMessage({browstorJsFileUrl:{key:t.browstorJsGetFileUrl.key,url:n+o.key+"/"+o.filesystemApi+"/"+o.dbName+(o.addAntiCacheParam?"?c="+Math.random():"")}});break;case"fetch":const s=e.request.url;if(!s.includes(n))return!1;const a=s.split("/"),i=a[a.length-3],c=a[a.length-2],l=a[a.length-1].split("?")[0];return e.respondWith(new Promise(async function(u){const d=await(await BrowstorJS.open(l,c==="1")).get(i);u(new Response(d,{status:d===null?404:200,statusText:"browstorJs File"}))})),!0}return!1}static async requestPersistentStorage(){return!navigator.storage||!navigator.storage.persist?!1:await navigator.storage.persisted()?!0:await navigator.storage.persist()}static async getStorageSpaceInfo(){if(!navigator.storage||!navigator.storage.estimate)return{available:-1,used:-1,free:-1};const e=await navigator.storage.estimate();return{available:e.quota,used:e.usage,free:e.quota-e.usage}}static isFilesystemApiAvailable(){return!(typeof Worker>"u"||typeof navigator>"u"||typeof navigator.storage>"u"||typeof navigator.storage.getDirectory>"u")}static async open(e="browstorJs",r=!1){const n=e+"__"+(r?"1":"0");if(typeof BrowstorJS.instances[n]<"u"&&BrowstorJS.instances[n])return BrowstorJS.instances[n];let t=new BrowstorJS;if(t.instanceId=n,r&&BrowstorJS.isFilesystemApiAvailable()){if(t.instanceId=n,BrowstorJS.instances[t.instanceId]=t,t.dbName=e,await t.startFilesystemWorker(),(await t.postMessageToWorker("test-support")).result)return t;console.warn("Fallback to IndexedDB because Filesystem API does not work"),delete BrowstorJS.instances[t.instanceId],t=new BrowstorJS}return new Promise(function(o,s){const a=indexedDB.open(e,1);a.onsuccess=function(){BrowstorJS.instances[t.instanceId]=t,t.dbName=e,t.idb=a.result,t.idb.addEventListener("close",function(){BrowstorJS.instances[t.instanceId]=null}),o(t)},a.onerror=function(i){console.error(i),s(i)},a.onupgradeneeded=function(i){const c=i.target.result;if(c.objectStoreNames.contains(e))return;c.createObjectStore(e,{keyPath:"key"}).createIndex("key","key",{unique:!0})}})}async postMessageToWorker(e,r=null,n=null){const t=this,o=t.workerMsgCount;return t.workerMsgCount++,new Promise(async function(s){t.workerMsgCallbacks[o]=async function(a){delete t.workerMsgCallbacks[o],s(a)},t.worker.postMessage({id:o,type:e,dbName:t.dbName,key:r,data:n})})}async set(e,r){const n=this;if(this.worker){await this.checkConnection(),await this.postMessageToWorker("write",e,r);return}return r=await n.convertValue(r,"data"),new Promise(async function(t,o){await n.checkConnection();const c=n.idb.transaction([n.dbName],"readwrite").objectStore(n.dbName).put({key:e,value:r});c.onsuccess=function(){t()},c.onerror=function(l){console.error(l),o(l)}})}async get(e){const r=this;return this.worker?(await this.checkConnection(),(await this.postMessageToWorker("read",e)).contents):new Promise(async function(n,t){await r.checkConnection();const i=r.idb.transaction([r.dbName],"readonly").objectStore(r.dbName).get(e);i.onsuccess=function(){n(i.result&&typeof i.result.value<"u"?r.convertValue(i.result.value,"blob"):null)},i.onerror=function(c){console.error(c),t(c)}})}async search(e){const r=this;if(this.worker){await this.checkConnection();const n=(await this.postMessageToWorker("list")).list,t={};for(let o=0;o<n.length;o++){const s=n[o],a=await this.get(s);await e(s,a)&&(t[s]=a)}return t}return new Promise(async function(n,t){await r.checkConnection();const s=r.idb.transaction([r.dbName],"readonly"),i=s.objectStore(r.dbName).openCursor(),c={};i.onsuccess=async function(l){const u=l.target.result;u&&(await e(u.key,u.value)&&(c[u.key]=await r.convertValue(u.value.value,"blob")),u.continue())},s.oncomplete=function(l){n(c)},i.onerror=function(l){console.error(l),t(l)}})}async getUrl(e,r=!1,n){if(this.worker)return await this.checkConnection(),(await this.postMessageToWorker("read-url",e)).url||r;if(typeof navigator.serviceWorker>"u"){const o=document.createElement("canvas");o.width=100,o.height=30;const s=o.getContext("2d");return s.font="9px sans-serif",s.fillStyle="black",s.fillRect(0,0,o.width,o.height),s.fillStyle="white",s.fillText("service worker unsupported",1,9,100),s.fillText("old browser or",1,18,100),s.fillText("in incognito mode",1,27,100),o.toDataURL("image/png")}const t=this;return new Promise(function(o){navigator.serviceWorker.addEventListener("message",s=>{s.data&&s.data.browstorJsFileUrl&&s.data.browstorJsFileUrl.key===e&&o(s.data.browstorJsFileUrl.url)}),navigator.serviceWorker.ready.then(function(s){s.active.postMessage({browstorJsGetFileUrl:{dbName:t.dbName,filesystemApi:t.worker?1:0,key:e,addAntiCacheParam:n}})})})}async getDataUri(e,r="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="){const n=await this.get(e);return n instanceof Blob?new Promise(function(t){const o=new FileReader;o.onload=function(s){t(o.result)},o.readAsDataURL(n)}):r}async remove(e){const r=this;if(this.worker){await this.checkConnection(),await this.postMessageToWorker("remove",e);return}return new Promise(async function(n,t){await r.checkConnection();const i=r.idb.transaction([r.dbName],"readwrite").objectStore(r.dbName).delete(e);i.onsuccess=function(){n()},i.onerror=function(c){console.error(c),t(c)}})}async getKeys(){const e=this;return this.worker?(await this.checkConnection(),(await this.postMessageToWorker("list")).list):new Promise(async function(r,n){await e.checkConnection();const o=e.idb.transaction([e.dbName],"readonly"),a=o.objectStore(e.dbName).openCursor(),i=[];a.onsuccess=async function(c){const l=c.target.result;l&&(i.push(l.key),l.continue())},a.onerror=function(c){console.error(c),n(c)},o.oncomplete=function(c){r(i)}})}async reset(){const e=this;if(this.worker){await this.checkConnection(),await this.postMessageToWorker("reset");return}return new Promise(async function(r,n){await e.checkConnection();const a=e.idb.transaction([e.dbName],"readwrite").objectStore(e.dbName).clear();a.onsuccess=async function(){r()},a.onerror=function(i){console.error(i),n(i)}})}async checkConnection(e=1){let r=this;if(this.worker){if(e>=50)throw new Error("Cannot connect to the Filesystem service worker");return new Promise(async function(t){const o=setTimeout(async function(){console.warn("Recreate BrowstorJS Filesystem Worker connection after inactivity"),r.startFilesystemWorker(),t(r.checkConnection(e+1))},100);await r.postMessageToWorker("init"),clearTimeout(o),t()})}return new Promise(async function(n,t){const o=r.idb;let s;try{s=o.transaction([r.dbName],"readwrite"),s.abort(),n();return}catch{}try{console.warn("Recreate BrowstorJS DB connection after inactivity"),s&&s.abort(),r.idb&&r.idb.close(),BrowstorJS.instances[r.instanceId]=null;const a=await BrowstorJS.open(r.dbName);r.idb=a.idb,n();return}catch{}})}async blobToBlobDataObject(e){const r={type:"browstorJsBlobData",blobData:null,blobType:e.type};return new Promise(function(n){const t=new FileReader;t.addEventListener("load",()=>{r.blobData=t.result,n(r)}),t.readAsArrayBuffer(e)})}blobDataObjectToBlob(e){return new Blob([e.blobData],{type:e.blobType})}async convertValue(e,r){return e==null?null:e instanceof Blob&&r==="data"?this.blobToBlobDataObject(e):r==="blob"&&typeof e=="object"&&typeof e.type<"u"&&e.type==="browstorJsBlobData"?this.blobDataObjectToBlob(e):e}async startFilesystemWorker(){const e=this,r='const maxRetries=500,directoryHandles={},urlFileMap=new Map,encoder=new TextEncoder,decoder=new TextDecoder;function bufferToStr(n){return decoder.decode(n)}function strToBuffer(n){return encoder.encode(n)}function readFromHandle(n){let i=1,r=[],t,a=0;function o(s,c){const l=n.read(s,{at:c}),f=s.byteLength;if(l!==f)throw new Error("Retry read because read bytes do not match buffer size. Actual: "+l+", Expected: "+f)}for(;i++<=10;)try{r=[],a=0,t=new ArrayBuffer(6),r.push(t),o(t,a),a+=t.byteLength;const s=parseInt(bufferToStr(t));return t=new ArrayBuffer(s),r.push(t),s&&(o(t,a),a+=t.byteLength),t=new ArrayBuffer(n.getSize()-a),r.push(t),o(t,a),r}catch(s){console.error(s)}throw console.error(["Cannot read buffers from handle",n,r]),new Error("Cannot read buffers from handle")}function writeToHandle(n,e){let r=1;e:for(;r++<=10;){n.truncate(0);let t=0;for(let a=0;a<e.length;a++){const o=e[a];if(o.byteLength){try{const s=n.write(o,{at:t}),c=o.byteLength;if(s!==c)throw new Error("Retry write because written bytes do not match buffer size. Actual: "+s+", Expected: "+c)}catch(s){console.error(s);continue e}t+=o.byteLength}}n.flush();return}throw console.error(["Cannot write buffers to handle",n,e]),new Error("Cannot write buffers to handle")}async function wait(n){return new Promise(function(e){setTimeout(e,n)})}async function getDirectory(n){if(directoryHandles[n])return directoryHandles[n];const e=await navigator.storage.getDirectory();return directoryHandles[n]=await e.getDirectoryHandle("browstorjs-"+n,{create:!0}),directoryHandles[n]}async function getFileHandle(n,e,i){let r=1;for(;r<=500;){r++;try{return await(await getDirectory(n)).getFileHandle(e,{create:i})}catch(t){if(t.code===8&&!i)return null;console.error(t),await wait(10)}}throw new Error("Cannot read "+e)}async function getSyncAccessHandle(n,e,i){const r=await getFileHandle(n,e,i);return r?r.createSyncAccessHandle():null}onmessage=async n=>{const e=n.data;let i="";if(e.key&&(i=e.key.replace(/[^a-z0-9-_]/ig,"-")),e.type==="init"&&(await getDirectory(e.dbName),self.postMessage({id:e.id})),e.type==="test-support"){let r=await getSyncAccessHandle(e.dbName,"__browstorjs_test__",!0);if(r)try{const t=new Uint8Array(1);t[0]=0,writeToHandle(r,[t]);const a=new Uint8Array(1);r.read(a,{at:0}),r.close(),await(await getDirectory(e.dbName)).removeEntry("__browstorjs_test__"),self.postMessage({id:e.id,result:a[0]===0});return}catch{r.close()}self.postMessage({id:e.id,result:!1})}if(e.type==="list"){const r=[],t=await getDirectory(e.dbName);for await(const a of t.values())if(a.kind==="file"){const o=await a.getFile();if(o!==null&&(r.push(o.name),e.data&&e.data.limit&&r.length>=e.data.limit))break}r.sort(),self.postMessage({id:e.id,list:r})}if(e.type==="read-url"){let r=await getFileHandle(e.dbName,i,!1),t=null;if(r){const a=await r.getFile();if(t=urlFileMap.get(a),!t){const o=await getSyncAccessHandle(e.dbName,i,!1);if(o){const s=readFromHandle(o);o.close();const c=JSON.parse(bufferToStr(s[1]));t=URL.createObjectURL(new Blob([s[2]],{type:c.blobType})),urlFileMap.set(a,t)}}}self.postMessage({id:e.id,url:t})}if(e.type==="read"){let r=await getSyncAccessHandle(e.dbName,i,!1),t=null,a=null,o=null;if(r&&(t=readFromHandle(r),r.close()),t){if(parseInt(bufferToStr(t[0])))try{a=JSON.parse(bufferToStr(t[1]))}catch(s){console.error(s)}if(a&&a.type==="blob"&&(o=new Blob([t[2]],{type:a.blobType})),!a||a.type==="json"){o=bufferToStr(t[2]);try{o=JSON.parse(o)}catch(s){console.error(s)}}}self.postMessage({id:e.id,meta:a,contents:o})}if(e.type==="write"){let r=await getSyncAccessHandle(e.dbName,i,!0);if(!r)throw new Error("Cannot open file "+i);let t=e.data,a="";t instanceof Blob?(a=JSON.stringify({type:"blob",blobType:t.type}),t=await new Promise(function(o){const s=new FileReader;s.addEventListener("load",()=>{o(s.result)}),s.readAsArrayBuffer(t)})):t=strToBuffer(JSON.stringify(t)),writeToHandle(r,[strToBuffer(a.length.toString().padStart(6)),strToBuffer(a),t]),r.close(),self.postMessage({id:e.id,result:0})}if(e.type==="remove"){const r=await getFileHandle(e.dbName,i,!1);if(r){const t=await r.getFile(),a=urlFileMap.get(t);a&&(URL.revokeObjectURL(a),urlFileMap.delete(t));const o=await getDirectory(e.dbName);try{await o.removeEntry(i)}catch(s){console.error(s)}self.postMessage({id:e.id})}}e.type==="reset"&&(await(await navigator.storage.getDirectory()).removeEntry("browstorjs-"+e.dbName,{recursive:!0}),delete directoryHandles[e.dbName],self.postMessage({id:e.id}))};';e.worker&&e.worker.terminate(),e.worker=new Worker(URL.createObjectURL(new Blob([r],{type:"application/javascript"}))),e.worker.addEventListener("message",function(n){const t=n.data;e.workerMsgCallbacks[t.id]&&e.workerMsgCallbacks[t.id](t)}),await e.postMessageToWorker("init")}}BrowstorJS.instances={};
